哈希表
unordered_map<char,char>t;
如果要创建新的，只需要t[x]=y，就可以创建一对键值对(key,value)
如果要判断哈希表中有无某个key元素x，可以使用t.count(x)这个函数
在49题中，用到了对哈希表的遍历,
for(auto i=t.begin();i!=t.end();i++{
    vector<char>v;
    v.push_back(i->second);//这里有点像struct指针的用法
}
在哈希表中查找某个值，t.find(key)如果找到返回该点位置，如果找不到那么返回哈希表的最后位置，即t.end()，在第一题中就有用到

上面的用法是哈希表两个元素

如果想建立哈希表单个元素 那么是使用 unordered_set<int>set
插入的话是用 set.insert()，如果遇到相同元素是不会插入的
查找某个元素 :set.count(x)
查找某个元素：set.find(x)!=set.end()如果找不到就会到最后一个位置

for循环中迭代器的用法
for(auto num:set)

字符串
转化成字符串的函数 ： to_string()
提取字符串中子串的函数：substr(pos,len) 从位置pos开始取长度为len的子串，如果pos越界会报错,如果pos+len越界，那么会取到底而不是报错

栈的使用
stack<int>t
在栈顶插入元素：t.push()
出栈操作：t.pop()
判断栈是否为空：t.empty()
返回栈顶元素： t.top()

队列的使用
queue<int>t
在队列后面插入元素：t.push()
出队操作：t.pop()
判断队列是否为空：t.empty()
返回队列最前面元素： t.front()
